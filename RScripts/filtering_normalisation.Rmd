---
title: "differential_methylation"
author: "Melanie Smith"
date: "2025-09-17"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

In this script I will take the raw DNAme data and calculate the differential methylation between preeclamptic and uncomplicated placental DNAme data  

# Load Libraries

```{r include=FALSE}

# Install the IlluminaHumanMethylationEPICmanifest package and the annotation package
# BiocManager::install(c(
#   "IlluminaHumanMethylationEPICmanifest",
#   "IlluminaHumanMethylationEPICanno.ilm10b4.hg19"
# ))
# BiocManager::install(c("minfi", "minfiData"))


# Data manipulation
library(dplyr)
library(tidyr)
library(readr)
library(stringr)
library(magrittr)
library(reshape2)

# DNAme
library(minfi)
library(minfiData)
library(wateRmelon)


# Prediction
library(planet)
library(EpiDISH)

# Plotting
library(ggplot2)
library(RColorBrewer)

```

# Set filtering paramaters

```{r}
# # Filtering Parameters
# pval_threshold <- 0.01         # detection p-value threshold
# missing_threshold <- 0.05      # fraction of samples allowed to fail (5%)
# bead_threshold  <- 3           # minimum bead count per probe
# bead_missing_threshold <- 0.05 # fraction of samples allowed with beadcount < bead_threshold
```


# Set Directories and files

```{r include=FALSE} 
# Set project directory
projectDir <- "D:/VM_Projects/20250820_DNAme_PE" # needs the "windows style" directory path (D:)

metaDataDir <- file.path(projectDir, "metaData")

baseDir <- file.path(projectDir, "rawData")

outdir <- file.path(projectDir, "outDir")
if (!dir.exists(outdir)) dir.create(outdir, recursive = TRUE)

# Set input files

import_samplesheet_file <- file.path(metaDataDir, "minfi_samplesheet.csv")
import_metadata_file <- file.path(metaDataDir, "pathology.csv")

# Set output files

```

# Import metadata file

```{r}
# Read in the minfi style samplesheet
targets <- read_csv(import_samplesheet_file)

# Read in the metadata samplesheet
pathology <- read_csv(import_metadata_file)
```

# Read in the idat files

```{r}
# create the RGChannelSet object
RGset <- read.metharray.exp(
  base = baseDir,
  targets = targets,
  extended = TRUE
  )

# Get an overview of the data
pData(RGset)
getManifest(RGset)

# Check the array type of your RGset
print(paste("The array type is", annotation(RGset)[1]))
print(paste("and the genome build is", annotation(RGset)[2]))
```

## Remove samples not required for this analysis

```{r}
# Remove SCP3492 - this sample is from an EOPE pregnancy
keep <- colnames(RGset) != "203013220099_R05C01"
# subset RGset
RGset <- RGset[, keep]

# Check the sample has been removed by looking at the number of colnames
RGset
# subset target as well
targets <- targets[keep,]


# Create vector of sample names where study equals "PE_placenta"
pe_samples <- targets$Basename[targets$study == "PE_placenta"]
print(paste("PE placenta samples identified:", length(pe_samples)))

# Inspect overlaps
intersect(pe_samples, colnames(RGset))
setdiff(pe_samples, colnames(RGset))  # will show missing/typos


# subset RGset
rgSet_pe <- RGset[,pe_samples]

stopifnot(length(pe_samples) == ncol(rgSet_pe))


# Check dimensions
print(paste("Final PE dataset dimensions:", paste(dim(rgSet_pe), collapse = " x ")))

# create the phenoData for use downstream
phenoData_pe <- data.frame(colData(rgSet_pe)) %>%
  dplyr::mutate(samplename = gsub("_T$", "", Sample_Name) %>%
                           gsub("_", "", .)) %>%
  dplyr::left_join(., pathology, by = "samplename") %>%
  dplyr::select(., samplename, Sentrix_ID, Basename, cohort, Outcome, Sex, maternalAge, GestationalAge)

# subset target as well
targets_pe <- subset(targets, Basename %in% pe_samples)
print(paste("Final targets dimensions:", paste(dim(targets_pe), collapse = " x ")))
```

# Quality control calculations on RAW data
# IMPORTANT: All QC calculations must be done on raw, unprocessed data

## 1. Detection p-values (on raw data)

```{r}
## detection p-values -> sex-aware with explicit ID matching
detP <- minfi::detectionP(rgSet_pe)
probe_ids <- rownames(detP)
probe_anno <- minfi::getAnnotation(rgSet_pe)   # ann with rownames probeIDs
probe_chr <- probe_anno[probe_ids, "chr"]

# autosomes/X/Y lists aligned to detP rows
autosome_probes <- probe_ids[probe_chr %in% paste0("chr", 1:22)]
x_chr_probes <- probe_ids[probe_chr == "chrX"]
y_chr_probes <- probe_ids[probe_chr == "chrY"]

# only keep probe IDs that exist in detP
x_chr_probes <- intersect(x_chr_probes, rownames(detP))
y_chr_probes <- intersect(y_chr_probes, rownames(detP))
autosome_probes <- intersect(autosome_probes, rownames(detP))

# map sample sex
sample_basenames <- colnames(detP)
sample_sex <- phenoData_pe$Sex[match(sample_basenames, phenoData_pe$Basename)]
male_samples <- sample_basenames[sample_sex == "M"]
female_samples <- sample_basenames[sample_sex == "F"]

# use variables for thresholds
pval_threshold <- 0.01
missing_threshold <- 0.05

autosome_failed_probes <- names(which(rowMeans(detP[autosome_probes, , drop = FALSE] > pval_threshold, na.rm = TRUE) > missing_threshold))
x_chr_failed_probes <- names(which(rowMeans(detP[x_chr_probes, , drop = FALSE] > pval_threshold, na.rm = TRUE) > missing_threshold))

y_chr_failed_probes <- character(0)
if (length(y_chr_probes) > 0 && length(male_samples) > 0) {
  y_idx <- intersect(colnames(detP), male_samples)
  if (length(y_idx) > 0) {
    y_chr_failed_probes <- names(which(rowMeans(detP[y_chr_probes, y_idx, drop = FALSE] > pval_threshold, na.rm = TRUE) > missing_threshold))
  }
}

missing_probes_sex_aware <- unique(c(autosome_failed_probes, x_chr_failed_probes, y_chr_failed_probes))

## beadcount: align columns and use fraction threshold
beadcount_mat <- wateRmelon::beadcount(rgSet_pe)
# align columns if necessary
if (!all(colnames(beadcount_mat) == colnames(rgSet_pe))) {
  colnames(beadcount_mat) <- colnames(rgSet_pe)
}
n_samples <- ncol(beadcount_mat)
bead_threshold <- 3
bead_missing_threshold <- 0.05

prop_fail <- rowSums(beadcount_mat < bead_threshold, na.rm = TRUE) / n_samples
low_bead_probes_original <- rownames(beadcount_mat)[prop_fail > bead_missing_threshold]

# sex-aware y-chr beadcount
low_bead_probes_sex_aware <- low_bead_probes_original
if (length(y_chr_probes) > 0 && length(male_samples) > 0) {
  male_idx <- intersect(colnames(beadcount_mat), male_samples)
  if (length(male_idx) > 0) {
    prop_fail_y <- rowSums(beadcount_mat[y_chr_probes, male_idx, drop = FALSE] < bead_threshold, na.rm = TRUE) / length(male_idx)
    low_y <- names(prop_fail_y)[prop_fail_y > bead_missing_threshold]
    low_bead_probes_sex_aware <- unique(c(low_bead_probes_sex_aware, low_y))
  }
}

```

## 3. Generate QC report

```{r}
# Generate comprehensive QC report on RAW data
# qcReport(rgSet = rgSet_pe, pdf = file.path(outdir, "qcReport.pdf"))

# Additional control plots
controlStripPlot(rgSet_pe, "HYBRIDIZATION")
controlStripPlot(rgSet_pe, "BISULFITE CONVERSION I")
controlStripPlot(rgSet_pe, "BISULFITE CONVERSION II")
```

# Data normalization (after all QC assessment)

## 1. Preprocessing for normalization

```{r}
# Convert to MethylSet - minimal processing for normalization input
MSet.raw <- preprocessRaw(rgSet_pe)

# Perform adjustedDasen normalization
print("Starting adjustedDasen normalization...")
dasen_result <- adjustedDasen(MSet.raw, 
                              normalize = TRUE,
                              fudge = 100,
                              ret2 = TRUE)

print("Normalization complete.")

```

## 2. Post-normalization quality assessment

```{r}
# Use densityPlot on the beta matrix
# Get phenotype data from the original MSet.raw object
phenoData <- pData(MSet.raw)

# Extract the beta matrix from the dasen result
# beta_matrix <- dasen_result$beta  # or dasen_result[[1]] if it's the first element

# Separate normalized object and beta matrix
if (is.list(dasen_result)) {
  norm_methylated_object <- dasen_result[["methylated"]]
  norm_unmethylated_object <- dasen_result[["unmethylated"]]
  if ("beta" %in% names(dasen_result)) {
    beta_matrix <- dasen_result[["beta"]]
  } else {
    beta_matrix <- dasen_result[[1]]
  }
} else {
  beta_matrix <- getBeta(dasen_result)          # extract beta values
}

# Quick checks
cat("Normalized methylated object class:", class(norm_methylated_object), "\n")
cat("Beta matrix dimensions:", dim(beta_matrix), "\n")

# Melt the data for plotting
beta_long <- melt(beta_matrix)
colnames(beta_long) <- c("Sample", "Beta")

# Plot
ggplot(beta_long, aes(x = Beta, color = Sample)) +
  geom_density() +
  theme_bw() +
  theme(legend.position = "none") +
  labs(title = "Density Plot of Beta Values After DASEN Normalisation")
```

## Combine detection p-value and beadcount failures

```{r}
# Combine detection p-value and beadcount failures
all_failed_probes <- intersect(
  unique(c(missing_probes_sex_aware, low_bead_probes_sex_aware)),
  rownames(beta_matrix)
)


cat("\n=== COMBINED FILTERING RESULTS ===\n")
cat("Probes failing detection p-value (sex-aware):", length(missing_probes_sex_aware), "\n")
cat("Probes failing beadcount (sex-aware):", length(low_bead_probes_sex_aware), "\n")
cat("Total unique failed probes:", length(all_failed_probes), "\n")
```

# Remove cross-hybridising probes (AFTER normalisation)

```{r}
tmp <- tempfile(fileext = ".gz")
download.file("https://github.com/zhou-lab/InfiniumAnnotationV1/raw/main/Anno/EPIC/archive/202209/EPIC.hg19.manifest.tsv.gz", tmp, mode = "wb")
ZhouProbeMasking <- readr::read_tsv(tmp)
# inspect names(ZhouProbeMasking)
# then:

cross_hybrid <- ZhouProbeMasking %>%
  filter(MASK_general) %>%
  pull(probeID)


print(paste("Cross-hybridizing probes identified:", length(cross_hybrid)))

# Remove cross-hybridizing probes from normalized beta matrix
beta_no_cross <- beta_matrix[!(rownames(beta_matrix) %in% cross_hybrid), ]

cat("\n=== CROSS-HYBRIDIZING PROBE REMOVAL ===\n")
cat("Probes before cross-hybrid removal:", nrow(beta_matrix), "\n")
cat("Cross-hybridizing probes removed:", sum(rownames(beta_matrix) %in% cross_hybrid), "\n")
cat("Probes after cross-hybrid removal:", nrow(beta_no_cross), "\n")

# Update beta_matrix for downstream analysis
beta_matrix <- beta_no_cross
```

# Apply additional probe filtering to normalized data

```{r}
# Apply QC-based probe filters (detection p-value and beadcount failures) 
# to the cross-hybrid filtered data
keep_probes <- !rownames(beta_matrix) %in% all_failed_probes
beta_filtered <- beta_matrix[keep_probes, ]

cat("\n=== FINAL PROBE FILTERING SUMMARY ===\n")
cat("Probes after cross-hybrid removal:", nrow(beta_matrix), "\n")
cat("Additional probes removed (QC failures):", sum(!keep_probes), "\n")  
cat("Final probes retained:", nrow(beta_filtered), "\n")
cat("Total probes removed from original:", nrow(beta_matrix) - nrow(beta_filtered), "\n")
cat("Percentage of original probes retained:", round(nrow(beta_filtered)/nrow(beta_matrix) * 100, 2), "%\n")
```

# Final chromosome distribution analysis

```{r}
# Get probe annotations for final dataset
array_type <- annotation(rgSet_pe)
if(array_type[1] == "IlluminaHumanMethylation450k") {
  library(IlluminaHumanMethylation450kanno.ilmn12.hg19)
  ann <- getAnnotation(IlluminaHumanMethylation450kanno.ilmn12.hg19)
} else if(array_type[1] == "IlluminaHumanMethylationEPIC") {
  library(IlluminaHumanMethylationEPICanno.ilm10b4.hg19)
  ann <- getAnnotation(IlluminaHumanMethylationEPICanno.ilm10b4.hg19)
}

# Match annotations to final filtered probes
filtered_probes <- rownames(beta_filtered)
ann_filtered <- ann[filtered_probes, ]

# Count probes by chromosome
chr_counts <- table(ann_filtered$chr)

# Separate autosomal, chrX, and chrY
autosomal_chrs <- paste0("chr", 1:22)
n_autosomal <- sum(chr_counts[names(chr_counts) %in% autosomal_chrs])
n_chrX <- ifelse("chrX" %in% names(chr_counts), chr_counts["chrX"], 0)
n_chrY <- ifelse("chrY" %in% names(chr_counts), chr_counts["chrY"], 0)

# Create comprehensive final summary
original_probes <- nrow(beta_matrix)

cross_hybrid_removed <- original_probes - nrow(beta_no_cross)
qc_removed <- nrow(beta_no_cross) - nrow(beta_filtered)

final_summary <- data.frame(
  Metric = c("Total samples", 
             "Original probes (post-normalization)", 
             "Cross-hybridizing probes removed", 
             "QC failure probes removed",
             "Final probes retained", 
             "Final autosomal CpGs", 
             "Final ChrX CpGs", 
             "Final ChrY CpGs",
             "Percentage retained"),
  Value = c(ncol(beta_filtered), 
            original_probes,
            cross_hybrid_removed,
            qc_removed,
            nrow(beta_filtered),
            n_autosomal, 
            n_chrX, 
            n_chrY,
            paste0(round(nrow(beta_filtered)/original_probes * 100, 2), "%"))
)

print("=== COMPREHENSIVE FINAL PROCESSING SUMMARY ===")
print(final_summary)

```

# Save processed data

```{r}
# # Save the final processed data
# save(beta_filtered, dasen_result, phenoData_pe, targets_pe, quality_summary,
#      file = file.path(outdir, "processed_methylation_data.RData"))
# 
# # Save summary statistics
# write.csv(final_summary, file = file.path(outdir, "processing_summary.csv"), row.names = FALSE)
# write.csv(quality_summary, file = file.path(outdir, "sample_quality_summary.csv"), row.names = FALSE)
# 
# print("Processing complete! Data saved successfully.")
```

# Save processed data for differential methylation analysis

```{r}
# ===== PREPARE ADDITIONAL OBJECTS FOR DOWNSTREAM ANALYSIS =====

# 1. Create M-values from beta values (needed for statistical testing)
# M-values are logit-transformed beta values: M = log2(beta/(1-beta))
# They have better statistical properties for differential analysis
M_filtered <- log2(beta_filtered / (1 - beta_filtered))

# Handle infinite values that can occur when beta = 0 or beta = 1
M_filtered[is.infinite(as.matrix(M_filtered))] <- NA

# 2. Get probe annotations for the final filtered dataset
array_type <- annotation(rgSet_pe)
if(array_type[1] == "IlluminaHumanMethylation450k") {
  library(IlluminaHumanMethylation450kanno.ilmn12.hg19)
  probe_annotations <- getAnnotation(IlluminaHumanMethylation450kanno.ilmn12.hg19)
} else if(array_type[1] == "IlluminaHumanMethylationEPIC") {
  library(IlluminaHumanMethylationEPICanno.ilm10b4.hg19)
  probe_annotations <- getAnnotation(IlluminaHumanMethylationEPICanno.ilm10b4.hg19)
}

# Rebuild probe annotations based on final beta_filtered probes
probe_annotations_filtered <- ann[rownames(beta_filtered), ]

# 3. Create a comprehensive sample metadata dataframe
# Ensure all samples in beta matrix have corresponding metadata
# Join metadata to beta sample IDs safely
sample_metadata <- phenoData_pe %>%
  dplyr::right_join(
    data.frame(Basename = colnames(beta_filtered)),
    by = "Basename"
  ) %>%
  dplyr::arrange(match(Basename, colnames(beta_filtered)))

# === Alignment verification ===
if (!identical(sample_metadata$Basename, colnames(beta_filtered))) {
  stop("❌ Sample metadata and beta matrix are misaligned! 
        Check Basename vs colnames(beta_filtered).")
} else {
  message("✅ Sample metadata perfectly aligned with beta matrix.")
}

# Optional: check for missing annotations
if (any(is.na(sample_metadata$Outcome)) | any(is.na(sample_metadata$Sex))) {
  warning("⚠️ Some samples are missing Outcome or Sex metadata.")
}

# 4. Create filtering summary for reproducibility
filtering_log <- list(
  original_probes = nrow(beta_matrix),
  cross_hybrid_removed = length(cross_hybrid[cross_hybrid %in% rownames(beta_matrix)]),
  detection_pval_removed = length(missing_probes_sex_aware),
  beadcount_removed = length(low_bead_probes_sex_aware),
  total_removed = nrow(beta_matrix) - nrow(beta_filtered),
  final_probes = nrow(beta_filtered),
  final_samples = ncol(beta_filtered),
  removed_probe_lists = list(
    cross_hybrid_probes = cross_hybrid,
    detection_failures = missing_probes_sex_aware,
    beadcount_failures = low_bead_probes_sex_aware,
    all_removed_probes = c(cross_hybrid[cross_hybrid %in% rownames(beta_matrix)], 
                          all_failed_probes)
  )
)

# 5. Create design matrix for common comparisons (optional but helpful)
# Example: comparing different outcomes
if("Outcome" %in% colnames(sample_metadata)) {
  design_matrix <- model.matrix(~ 0 + Outcome, data = sample_metadata)
  colnames(design_matrix) <- gsub("Outcome", "", colnames(design_matrix))
}

# ===== SAVE ALL OBJECTS FOR DOWNSTREAM ANALYSIS =====

# Core objects needed for differential methylation
save(
  # Essential data matrices
  beta_filtered,           # Beta values (for visualization, reporting)
  M_filtered,             # M-values (for statistical testing)
  
  # Sample information  
  sample_metadata,        # Complete sample metadata
  phenoData_pe,          # Original phenotype data
  targets_pe,            # Original targets
  
  # Probe information
  probe_annotations_filtered,  # Annotations for final probe set
  
  # Quality control
  # quality_summary,        # Sample quality metrics
  filtering_log,          # Complete filtering history
  
  # Normalization results
  dasen_result,          # Full normalization results
  
  # Optional design matrix
  design_matrix,         # If created above
  
  file = file.path(outdir, "processed_methylation_data_complete.RData")
)

# Also save individual objects for flexibility
saveRDS(beta_filtered, file = file.path(outdir, "beta_values_filtered.rds"))
saveRDS(M_filtered, file = file.path(outdir, "M_values_filtered.rds"))
saveRDS(sample_metadata, file = file.path(outdir, "sample_metadata.rds"))
saveRDS(probe_annotations_filtered, file = file.path(outdir, "probe_annotations.rds"))

# Save summary statistics
write.csv(final_summary, file = file.path(outdir, "processing_summary.csv"), row.names = FALSE)
write.csv(quality_summary, file = file.path(outdir, "sample_quality_summary.csv"), row.names = FALSE)

# Save filtering details for reproducibility
saveRDS(filtering_log, file = file.path(outdir, "filtering_log.rds"))

```

```{r}
# ===== VERIFICATION CHECKS =====

cat("\n=== DATA VERIFICATION FOR DOWNSTREAM ANALYSIS ===\n")
cat("Beta matrix dimensions:", dim(beta_filtered), "\n")
cat("M-values matrix dimensions:", dim(M_filtered), "\n") 
cat("Sample metadata rows:", nrow(sample_metadata), "\n")
cat("Probe annotations rows:", nrow(probe_annotations_filtered), "\n")

# === Data integrity checks ===
cat("\nData integrity checks:\n")

# Check beta vs M-value consistency
cat("- Beta and M-values same dimensions:", 
    identical(dim(beta_filtered), dim(M_filtered)), "\n")

# Check sample alignment
if (!identical(sample_metadata$Basename, colnames(beta_filtered))) {
  stop("❌ Metadata Basename does not match beta matrix column names. 
        Recheck sample alignment.")
} else {
  cat("- Sample metadata matches beta columns: TRUE\n")
}

# Check probe annotation alignment
if (!identical(rownames(beta_filtered), rownames(probe_annotations_filtered))) {
  stop("❌ Probe annotations do not match beta matrix rownames.")
} else {
  cat("- Probe annotations match beta rows: TRUE\n")
}

# === Missing value checks ===
cat("\nMissing value summary:\n")
cat("- Beta values with NA:", sum(is.na(beta_filtered)), "\n")
cat("- M-values with NA/Inf:", sum(is.na(M_filtered) | is.infinite(M_filtered)), "\n")
cat("- Sample metadata missing:", 
    sum(is.na(sample_metadata$Outcome)), "outcomes,", 
    sum(is.na(sample_metadata$Sex)), "sex\n")

```


---
title: "differential_methylation"
author: "Melanie Smith"
date: "2025-09-17"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

In this script I will take the raw DNAme data and calculate the differential methylation between preeclamptic and uncomplicated placental DNAme data  

# Load Libraries

```{r include=FALSE}

# Install the IlluminaHumanMethylationEPICmanifest package and the annotation package
# BiocManager::install(c(
#   "IlluminaHumanMethylationEPICmanifest",
#   "IlluminaHumanMethylationEPICanno.ilm10b4.hg19"
# ))
# BiocManager::install(c("minfi", "minfiData"))


# Data manipulation
library(dplyr)
library(tidyr)
library(readr)
library(stringr)
library(magrittr)
library(reshape2)

# DNAme
library(minfi)
library(minfiData)
library(wateRmelon)
library(IlluminaHumanMethylationEPICanno.ilm10b4.hg19)


# Prediction
library(planet)
library(EpiDISH)

# Plotting
library(ggplot2)
library(RColorBrewer)

```

# Set filtering paramaters

```{r}
# # Filtering Parameters
pval_threshold <- 0.01         # detection p-value threshold
bead_threshold  <- 3           # minimum bead count per probe
sample_fail_threshold <- 0.05   # 5% of probes
# bead_missing_threshold <- 0.05 # fraction of samples allowed with beadcount < bead_threshold
```


# Set Directories and files

```{r include=FALSE} 
# Set project directory
projectDir <- "D:/VM_Projects/20250820_DNAme_PE" # needs the "windows style" directory path (D:)

metaDataDir <- file.path(projectDir, "metaData")

baseDir <- file.path(projectDir, "rawData")

outdir <- file.path(projectDir, "outDir")
if (!dir.exists(outdir)) dir.create(outdir, recursive = TRUE)

# Set input files

import_samplesheet_file <- file.path(metaDataDir, "minfi_samplesheet.csv")
import_metadata_file <- file.path(metaDataDir, "pathology.csv")

# Set output files

```

# Import metadata file

```{r}
# Read in the minfi style samplesheet
targets <- read_csv(import_samplesheet_file)

# Read in the metadata samplesheet
pathology <- read_csv(import_metadata_file)
```

# Read in the idat files

```{r}
# create the RGChannelSet object
RGset <- read.metharray.exp(
  base = baseDir,
  targets = targets,
  extended = TRUE
  )

# Get an overview of the data
pData(RGset)
getManifest(RGset)

# Check the array type of your RGset
print(paste("The array type is", annotation(RGset)[1]))
print(paste("and the genome build is", annotation(RGset)[2]))
```

## Remove samples not required for this analysis

```{r}
# Remove SCP3492 - this sample is from an EOPE pregnancy
keep <- colnames(RGset) != "203013220099_R05C01"
# subset RGset
RGset <- RGset[, keep]

# Check the sample has been removed by looking at the number of colnames
RGset
# subset target as well
targets <- targets[keep,]


# Create vector of sample names where study equals "PE_placenta"
pe_samples <- targets$Basename[targets$study == "PE_placenta"]
print(paste("PE placenta samples identified:", length(pe_samples)))

# Inspect overlaps
intersect(pe_samples, colnames(RGset))
setdiff(pe_samples, colnames(RGset))  # will show missing/typos


# subset RGset
rgSet_pe <- RGset[,pe_samples]

stopifnot(length(pe_samples) == ncol(rgSet_pe))


# Check dimensions
print(paste("Final PE dataset dimensions:", paste(dim(rgSet_pe), collapse = " x ")))

# create the phenoData for use downstream
phenoData_pe <- data.frame(colData(rgSet_pe)) %>%
  dplyr::mutate(samplename = gsub("_T$", "", Sample_Name) %>%
                           gsub("_", "", .)) %>%
  dplyr::left_join(., pathology, by = "samplename") %>%
  dplyr::select(., samplename, Sentrix_ID, Basename, cohort, Outcome, Sex, maternalAge, GestationalAge)

# subset target as well
targets_pe <- subset(targets, Basename %in% pe_samples)
print(paste("Final targets dimensions:", paste(dim(targets_pe), collapse = " x ")))
```

# Quality control calculations on RAW data
# IMPORTANT: All QC calculations must be done on raw, unprocessed data

## 1. Detection p-values (on raw data)

```{r}
## detection p-values -> sex-aware with explicit ID matching
detP <- minfi::detectionP(rgSet_pe)
probe_ids <- rownames(detP)
probe_anno <- minfi::getAnnotation(rgSet_pe)   # ann with rownames probeIDs
probe_chr <- probe_anno[probe_ids, "chr"]

# autosomes/X/Y lists aligned to detP rows
autosome_probes <- probe_ids[probe_chr %in% paste0("chr", 1:22)]
x_chr_probes <- probe_ids[probe_chr == "chrX"]
y_chr_probes <- probe_ids[probe_chr == "chrY"]

# only keep probe IDs that exist in detP
x_chr_probes <- intersect(x_chr_probes, rownames(detP))
y_chr_probes <- intersect(y_chr_probes, rownames(detP))
autosome_probes <- intersect(autosome_probes, rownames(detP))

# map sample sex
sample_basenames <- colnames(detP)
sample_sex <- phenoData_pe$Sex[match(sample_basenames, phenoData_pe$Basename)]
male_samples <- sample_basenames[sample_sex == "M"]
female_samples <- sample_basenames[sample_sex == "F"]

# use variables for thresholds
pval_threshold <- 0.01
missing_threshold <- 0.05

autosome_failed_probes <- names(which(rowMeans(detP[autosome_probes, , drop = FALSE] > pval_threshold, na.rm = TRUE) > missing_threshold))
x_chr_failed_probes <- names(which(rowMeans(detP[x_chr_probes, , drop = FALSE] > pval_threshold, na.rm = TRUE) > missing_threshold))

y_chr_failed_probes <- character(0)
if (length(y_chr_probes) > 0 && length(male_samples) > 0) {
  y_idx <- intersect(colnames(detP), male_samples)
  if (length(y_idx) > 0) {
    y_chr_failed_probes <- names(which(rowMeans(detP[y_chr_probes, y_idx, drop = FALSE] > pval_threshold, na.rm = TRUE) > missing_threshold))
  }
}

missing_probes_sex_aware <- unique(c(autosome_failed_probes, x_chr_failed_probes, y_chr_failed_probes))

## beadcount: align columns and use fraction threshold
beadcount_mat <- wateRmelon::beadcount(rgSet_pe)
# align columns if necessary
if (!all(colnames(beadcount_mat) == colnames(rgSet_pe))) {
  colnames(beadcount_mat) <- colnames(rgSet_pe)
}
n_samples <- ncol(beadcount_mat)
bead_threshold <- 3
bead_missing_threshold <- 0.05

prop_fail <- rowSums(beadcount_mat < bead_threshold, na.rm = TRUE) / n_samples
low_bead_probes_original <- rownames(beadcount_mat)[prop_fail > bead_missing_threshold]

# sex-aware y-chr beadcount
low_bead_probes_sex_aware <- low_bead_probes_original
if (length(y_chr_probes) > 0 && length(male_samples) > 0) {
  male_idx <- intersect(colnames(beadcount_mat), male_samples)
  if (length(male_idx) > 0) {
    prop_fail_y <- rowSums(beadcount_mat[y_chr_probes, male_idx, drop = FALSE] < bead_threshold, na.rm = TRUE) / length(male_idx)
    low_y <- names(prop_fail_y)[prop_fail_y > bead_missing_threshold]
    low_bead_probes_sex_aware <- unique(c(low_bead_probes_sex_aware, low_y))
  }
}

```

## 3. Generate QC report

```{r}
# Generate comprehensive QC report on RAW data
# qcReport(rgSet = rgSet_pe, pdf = file.path(outdir, "qcReport.pdf"))

# Additional control plots
controlStripPlot(rgSet_pe, "HYBRIDIZATION")
controlStripPlot(rgSet_pe, "BISULFITE CONVERSION I")
controlStripPlot(rgSet_pe, "BISULFITE CONVERSION II")
```

## Sample level QC report

```{r}
# ===== SEX-AWARE SAMPLE-LEVEL QUALITY SUMMARY (robust) =====

# thresholds
pval_threshold <- 0.01
bead_threshold <- 3
sample_fail_threshold <- 0.05   # 5% of probes

# make sure phenoData_pe exists and maps to detP columns
if (!"phenoData_pe" %in% ls()) stop("phenoData_pe not found. Run earlier phenotype creation steps first.")
sample_basenames <- colnames(detP)

# clean/standardise sex assignment from phenoData_pe
sex_vec_raw <- phenoData_pe$Sex[match(sample_basenames, phenoData_pe$Basename)]
sex_vec <- ifelse(is.na(sex_vec_raw), NA, toupper(substr(as.character(sex_vec_raw), 1, 1)))
# now sex_vec contains "M", "F", or NA
message("Sex distribution (sample-level):"); print(table(sex_vec, useNA = "ifany"))

# ensure probe lists align with available rows in detP / beadcount_mat
autosome_probes <- intersect(autosome_probes, rownames(detP))
x_chr_probes    <- intersect(x_chr_probes, rownames(detP))
y_chr_probes    <- intersect(y_chr_probes, rownames(detP))

message("Probe counts used for sex-aware QC: autosomes=", length(autosome_probes),
        ", chrX=", length(x_chr_probes), ", chrY=", length(y_chr_probes))

# helper: get probe set appropriate for a sample's sex
get_probes_for_sample <- function(sex) {
  if (is.na(sex)) {
    # unknown sex: use autosomes + X (conservative)
    probes <- c(autosome_probes, x_chr_probes)
  } else if (sex == "M") {
    probes <- c(autosome_probes, x_chr_probes, y_chr_probes)
  } else if (sex == "F") {
    probes <- c(autosome_probes, x_chr_probes)
  } else {
    probes <- c(autosome_probes, x_chr_probes)
  }
  # keep only probes that actually exist in detP/beadcount_mat
  intersect(probes, rownames(detP))
}

# compute per-sample metrics
sample_mean_det <- colMeans(detP, na.rm = TRUE)

sample_det_frac <- vapply(seq_along(sample_basenames), FUN.VALUE = numeric(1), FUN = function(i) {
  samp <- sample_basenames[i]
  probes <- get_probes_for_sample(sex_vec[i])
  if (length(probes) == 0) return(NA_real_)
  mean(detP[probes, samp] > pval_threshold, na.rm = TRUE)
})

sample_bead_frac <- vapply(seq_along(sample_basenames), FUN.VALUE = numeric(1), FUN = function(i) {
  samp <- sample_basenames[i]
  probes <- get_probes_for_sample(sex_vec[i])
  if (length(probes) == 0) return(NA_real_)
  # beadcount_mat must have same rows/cols as detP (we aligned columns earlier)
  mean(beadcount_mat[probes, samp] < bead_threshold, na.rm = TRUE)
})

# assemble the summary (use phenoData_pe, present at this stage)
quality_summary <- data.frame(
  Basename = sample_basenames,
  Mean_detection_pval = sample_mean_det,
  Fraction_failed_probes_detection_sexaware = sample_det_frac,
  Fraction_failed_probes_beadcount_sexaware = sample_bead_frac,
  Sex_reported = sex_vec,
  stringsAsFactors = FALSE
)

quality_summary <- dplyr::left_join(phenoData_pe, quality_summary, by = "Basename")

# Robust QC_fail booleans: treat NA as FALSE so missing info doesn't auto-fail
detect_fail_bool <- ifelse(is.na(quality_summary$Fraction_failed_probes_detection_sexaware),
                           FALSE,
                           quality_summary$Fraction_failed_probes_detection_sexaware > sample_fail_threshold)
bead_fail_bool <- ifelse(is.na(quality_summary$Fraction_failed_probes_beadcount_sexaware),
                         FALSE,
                         quality_summary$Fraction_failed_probes_beadcount_sexaware > sample_fail_threshold)

quality_summary <- quality_summary %>%
  dplyr::mutate(
    QC_fail = detect_fail_bool | bead_fail_bool,
    QC_fail_reason = dplyr::case_when(
      QC_fail & detect_fail_bool & bead_fail_bool ~ "detection;beadcount",
      QC_fail & detect_fail_bool ~ "detection",
      QC_fail & bead_fail_bool ~ "beadcount",
      TRUE ~ "pass"
    )
  )

# quick diagnostics
message("QC failures summary:")
print(table(quality_summary$QC_fail, useNA = "ifany"))
head(quality_summary)

# save QC csv (optional)
write.csv(quality_summary, file = file.path(outdir, "sample_quality_summary.csv"), row.names = FALSE)

```


# Data normalization (after all QC assessment)

## 1. Preprocessing and normalisation

```{r}
# Convert to MethylSet - minimal processing for normalisation input
MSet.raw <- preprocessRaw(rgSet_pe)

# Perform adjustedDasen normalization
print("Starting adjustedDasen normalization...")
dasen_result <- adjustedDasen(MSet.raw, 
                              normalize = TRUE,
                              fudge = 100,
                              ret2 = TRUE)

print("Normalization complete.")

```

## 2. Post-normalization quality assessment

```{r}
# Use densityPlot on the beta matrix
# Get phenotype data from the original MSet.raw object
phenoData <- pData(MSet.raw)
# Separate normalized object and beta matrix
if (is.list(dasen_result)) {
  norm_methylated_object <- dasen_result[["methylated"]]
  norm_unmethylated_object <- dasen_result[["unmethylated"]]
  if ("beta" %in% names(dasen_result)) {
    beta_matrix_initial <- dasen_result[["beta"]]
  } else {
    beta_matrix_initial <- dasen_result[[1]]
  }
} else {
  beta_matrix_initial <- getBeta(dasen_result) # extract beta values
}

# Filter probes to match annotation
probe_annotations <- getAnnotation(IlluminaHumanMethylationEPICanno.ilm10b4.hg19)
valid_probes <- intersect(rownames(beta_matrix_initial), rownames(probe_annotations))
cat("Total probes in beta_matrix_initial:", nrow(beta_matrix_initial), "\n")
cat("Probes in annotation:", nrow(probe_annotations), "\n")
cat("Probes retained after filtering:", length(valid_probes), "\n")
cat("Probes removed (not in annotation):", nrow(beta_matrix_initial) - length(valid_probes), "\n")
beta_matrix_initial <- beta_matrix_initial[valid_probes, ]
original_probes <- nrow(beta_matrix_initial)
cat("Updated beta_matrix_initial dimensions:", dim(beta_matrix_initial), "\n")

# Continue with existing code
cat("Normalized methylated object class:", class(norm_methylated_object), "\n")
cat("Beta matrix dimensions:", dim(beta_matrix_initial), "\n")
# Melt the data for plotting
beta_long <- melt(beta_matrix_initial)
colnames(beta_long) <- c("Sample", "Beta")
# Plot
ggplot(beta_long, aes(x = Beta, color = Sample)) +
  geom_density() +
  theme_bw() +
  theme(legend.position = "none") +
  labs(title = "Density Plot of Beta Values After DASEN Normalisation")
```

## Combine detection p-value and beadcount failures

```{r}
# Combine detection p-value and beadcount failures
all_failed_probes <- intersect(
  unique(c(missing_probes_sex_aware, low_bead_probes_sex_aware)),
  rownames(beta_matrix_initial)
)


cat("\n=== COMBINED FILTERING RESULTS ===\n")
cat("Probes failing detection p-value (sex-aware):", length(missing_probes_sex_aware), "\n")
cat("Probes failing beadcount (sex-aware):", length(low_bead_probes_sex_aware), "\n")
cat("Total unique failed probes:", length(all_failed_probes), "\n")
```

# Remove cross-hybridising probes (AFTER normalisation)

```{r}
tmp <- tempfile(fileext = ".gz")
download.file("https://github.com/zhou-lab/InfiniumAnnotationV1/raw/main/Anno/EPIC/archive/202209/EPIC.hg19.manifest.tsv.gz", tmp, mode = "wb")
ZhouProbeMasking <- readr::read_tsv(tmp)
# inspect names(ZhouProbeMasking)
# then:

cross_hybrid <- ZhouProbeMasking %>%
  filter(MASK_general) %>%
  pull(probeID)


print(paste("Cross-hybridizing probes identified:", length(cross_hybrid)))

# Remove cross-hybridizing probes from normalized beta matrix
beta_no_cross <- beta_matrix_initial[!(rownames(beta_matrix_initial) %in% cross_hybrid), ]
after_crosshyb  <- nrow(beta_no_cross)

cat("\n=== CROSS-HYBRIDIZING PROBE REMOVAL ===\n")
cat("Probes before cross-hybrid removal:", nrow(beta_matrix_initial), "\n")
cat("Cross-hybridising probes removed:", sum(rownames(beta_matrix_initial) %in% cross_hybrid), "\n")
cat("Probes after cross-hybrid removal:", nrow(beta_no_cross), "\n")

# Update beta_matrix for downstream analysis
beta_matrix_no_cross <- beta_no_cross
```

# Apply additional probe filtering to normalised data

```{r}
# Apply QC-based probe filters (detection p-value and beadcount failures) 
# to the cross-hybrid filtered data
keep_probes <- !rownames(beta_matrix_no_cross) %in% all_failed_probes
beta_filtered <- beta_matrix_no_cross[keep_probes, ]
# count the remaining probes
after_qc <- nrow(beta_filtered)

# Recalculate M_filtered after filtering
epsilon <- 1e-6
beta_filtered[beta_filtered <= 0] <- epsilon
beta_filtered[beta_filtered >= 1] <- 1 - epsilon
M_filtered <- log2(beta_filtered / (1 - beta_filtered))

cross_hybrid_removed <- original_probes - after_crosshyb
qc_removed           <- after_crosshyb - after_qc

cat("\n=== FINAL PROBE FILTERING SUMMARY ===\n")
cat("Probes after cross-hybrid removal:", nrow(beta_matrix_no_cross), "\n")
cat("Additional probes removed (QC failures):", sum(!keep_probes), "\n")  
cat("Final probes retained:", nrow(beta_filtered), "\n")
cat("Total probes removed from original:", nrow(beta_matrix_initial) - nrow(beta_filtered), "\n")
cat("Percentage of original probes retained:", round(nrow(beta_filtered)/nrow(beta_matrix_initial) * 100, 2), "%\n")
```

# Final chromosome distribution analysis

```{r}
# ===== FINAL PROBE ANNOTATIONS & CHROMOSOME DISTRIBUTION =====

# 2. Subset to final filtered probes
probe_annotations_filtered <- probe_annotations[rownames(beta_filtered), ]

# 3. Count probes by chromosome
chr_counts <- table(probe_annotations_filtered$chr)

autosomal_chrs <- paste0("chr", 1:22)
n_autosomal <- sum(chr_counts[names(chr_counts) %in% autosomal_chrs])
n_chrX <- ifelse("chrX" %in% names(chr_counts), chr_counts["chrX"], 0)
n_chrY <- ifelse("chrY" %in% names(chr_counts), chr_counts["chrY"], 0)

# 4. Add to final summary
final_summary <- data.frame(
  Metric = c("Total samples", 
             "Original probes (post-normalization)", 
             "Cross-hybridizing probes removed", 
             "QC failure probes removed",
             "Final probes retained", 
             "Final autosomal CpGs", 
             "Final ChrX CpGs", 
             "Final ChrY CpGs",
             "Percentage retained"),
  Value = c(ncol(beta_filtered), 
            original_probes,
            cross_hybrid_removed,
            qc_removed,
            nrow(beta_filtered),
            n_autosomal, 
            n_chrX, 
            n_chrY,
            paste0(round(nrow(beta_filtered) / original_probes * 100, 2), "%"))
)

print("=== COMPREHENSIVE FINAL PROCESSING SUMMARY ===")
print(final_summary)

# 5. Save filtered probe annotations
saveRDS(probe_annotations_filtered,
        file = file.path(outdir, "probe_annotations_filtered.rds"))

```

# Save processed data for differential methylation analysis

```{r}
# ===== PREPARE ADDITIONAL OBJECTS FOR DOWNSTREAM ANALYSIS =====
# 
# # 1. Create M-values from beta values (needed for statistical testing)
# # M-values are logit-transformed beta values: M = log2(beta/(1-beta))
# # They have better statistical properties for differential analysis
# # using minfi
# # minfi_filtered_m <- minfi::logit2(beta_filtered)
# M_filtered <- log2(beta_filtered / (1 - beta_filtered))
# 
# # Handle infinite values that can occur when beta = 0 or beta = 1
# M_filtered[is.infinite(as.matrix(M_filtered))] <- NA

# Verify no infinite values in M_filtered
if (any(is.infinite(as.matrix(M_filtered)))) {
  stop("Infinite values found in M_filtered. Check epsilon adjustment.")
}

# 4. Create filtering summary for reproducibility
filtering_log <- list(
  original_probes = nrow(beta_matrix_initial),
  cross_hybrid_removed = length(cross_hybrid[cross_hybrid %in% rownames(beta_matrix_initial)]),
  detection_pval_removed = length(missing_probes_sex_aware),
  beadcount_removed = length(low_bead_probes_sex_aware),
  total_removed = nrow(beta_matrix_initial) - nrow(beta_filtered),
  final_probes = nrow(beta_filtered),
  final_samples = ncol(beta_filtered),
  removed_probe_lists = list(
    cross_hybrid_probes = cross_hybrid,
    detection_failures = missing_probes_sex_aware,
    beadcount_failures = low_bead_probes_sex_aware,
    all_removed_probes = c(cross_hybrid[cross_hybrid %in% rownames(beta_matrix_initial)], 
                          all_failed_probes)
  )
)

# ===== SAVE ALL OBJECTS FOR DOWNSTREAM ANALYSIS =====

# Core objects needed for differential methylation
save(
  beta_filtered, M_filtered, phenoData_pe, targets_pe, probe_annotations_filtered,
  filtering_log, dasen_result,
  file = file.path(outdir, "processed_methylation_data_complete.RData")
)

# Also save individual objects for flexibility
saveRDS(beta_filtered, file = file.path(outdir, "beta_values_filtered.rds"))
saveRDS(M_filtered, file = file.path(outdir, "M_values_filtered.rds"))
saveRDS(probe_annotations_filtered, file = file.path(outdir, "probe_annotations.rds"))

# Save summary statistics
write.csv(final_summary, file = file.path(outdir, "processing_summary.csv"), row.names = FALSE)
write.csv(quality_summary, file = file.path(outdir, "sample_quality_summary.csv"), row.names = FALSE)

# Save filtering details for reproducibility
saveRDS(filtering_log, file = file.path(outdir, "filtering_log.rds"))

```

```{r}
# ===== VERIFICATION CHECKS =====

cat("\n=== DATA VERIFICATION FOR DOWNSTREAM ANALYSIS ===\n")
cat("Beta matrix dimensions:", dim(beta_filtered), "\n")
cat("M-values matrix dimensions:", dim(M_filtered), "\n") 
cat("Sample metadata rows:", nrow(phenoData_pe), "\n")
cat("Probe annotations rows:", nrow(probe_annotations_filtered), "\n")

# === Data integrity checks ===
cat("\nData integrity checks:\n")

# Check beta vs M-value consistency
cat("- Beta and M-values same dimensions:", 
    identical(dim(beta_filtered), dim(M_filtered)), "\n")

# Check sample alignment
if (!identical(phenoData_pe$Basename, colnames(beta_filtered))) {
  stop("❌ Metadata Basename does not match beta matrix column names. 
        Recheck sample alignment.")
} else {
  cat("- Sample metadata matches beta columns: TRUE\n")
}

# Check probe annotation alignment
if (!identical(rownames(beta_filtered), rownames(probe_annotations_filtered))) {
  stop("❌ Probe annotations do not match beta matrix rownames.")
} else {
  cat("- Probe annotations match beta rows: TRUE\n")
}

# === Missing value checks ===
cat("\nMissing value summary:\n")
cat("- Beta values with NA:", sum(is.na(beta_filtered)), "\n")
cat("- M-values with NA/Inf:", sum(is.na(M_filtered) | is.infinite(as.matrix(M_filtered))), "\n")
cat("- Sample metadata missing:",
    sum(is.na(phenoData_pe$Outcome)), "outcomes,",
    sum(is.na(phenoData_pe$Sex)), "sex\n")

```

